<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Retro Computer Vision</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/paho-mqtt/1.0.1/mqttws31.min.js" type="text/javascript"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Noto Sans SC', sans-serif;
            background-color: #151515;
            color: #DCC9A9;
            padding: 20px;
            margin: 0 auto;
        }
        
        .main-wrapper {
            display: flex;
            max-width: 900px;
            margin: 0 auto;
            gap: 20px;
            align-items: stretch;
        }
        
        .left-panel {
            flex: 1;
            min-width: 320px;
        }
        
        .right-panel {
            flex: 1;
            min-width: 300px;
            display: flex;
            flex-direction: column;
        }
        
        .container {
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        
        .header {
            background-color: #151515;
            padding: 20px;
            border-top-left-radius: 20px;
            border-top-right-radius: 20px;
            position: relative;
        }
        
        .header-content {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .box-icon {
            width: 50px;
            height: 50px;
            background-color: #DCC9A9;
            margin-right: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 30px;
            font-weight: bold;
            border-radius: 5px;
            color: #151515;
        }
        
        .title-area {
            flex-grow: 1;
        }
        
        .subtitle {
            font-size: 12px;
            color: #DCC9A9;
            margin-bottom: 5px;
        }
        
        .main-title {
            font-size: 24px;
            font-weight: bold;
            color: #DCC9A9;
        }
        
        .right-text {
            color: #B83A2D;
            font-size: 16px;
            text-align: right;
            position: absolute;
            right: 20px;
            top: 20px;
        }
        
        .color-panel {
            background-color: #DCC9A9;
            padding: 20px;
            border-radius: 15px;
            margin-top: 10px;
        }
        
        .color-title {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .color-title-left {
            font-size: 22px;
            font-weight: bold;
            color: #151515;
        }
        
        .color-title-right {
            font-size: 22px;
            color: #151515;
        }
        
        .color-hex {
            font-size: 14px;
            margin-top: 5px;
            color: #151515;
        }
        
        .color-note {
            font-size: 14px;
            color: #151515;
            text-align: right;
        }
        
        .color-swatches {
            margin-top: 15px;
        }
        
        .color-swatch {
            height: 60px;
            border-radius: 10px;
            margin-bottom: 10px;
            position: relative;
            display: flex;
            align-items: center;
            padding-left: 15px;
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .color-swatch:hover {
            transform: translateX(5px);
        }
        
        .color-swatch:active {
            transform: translateX(10px);
        }
        
        .color-swatch-hex {
            color: white;
            font-size: 16px;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
        }
        
        .red-swatch {
            background-color: #B83A2D;
        }
        
        .green-swatch {
            background-color: #4E6851;
        }
        
        .image-area {
            background-color: #E26654;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .footer {
            background-color: #151515;
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .logo {
            display: flex;
            align-items: center;
        }
        
        .logo-circle {
            width: 40px;
            height: 40px;
            background-color: #4E6851;
            border-radius: 50%;
            margin-right: 10px;
            position: relative;
        }
        
        .logo-circle::after {
            content: "";
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: #151515;
            top: 10px;
            left: 10px;
        }
        
        .logo-text {
            font-size: 22px;
            color: #4E6851;
            font-weight: bold;
        }
        
        .footer-text {
            font-size: 12px;
            color: #4E6851;
            text-align: right;
        }
        
        .footer-divider {
            width: 60px;
            height: 2px;
            background-color: #4E6851;
            margin: 5px 0 5px auto;
        }
        
        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }
        
        .status-connected {
            background-color: #4E6851;
        }
        
        .status-disconnected {
            background-color: #B83A2D;
        }
        
        .connection-status {
            font-size: 12px;
            color: #DCC9A9;
            text-align: center;
            margin-top: 10px;
        }
        
        /* Text input panel styles */
        .text-panel {
            background-color: #DCC9A9;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 0;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        
        .text-panel-title {
            font-size: 22px;
            font-weight: bold;
            color: #151515;
            margin-bottom: 15px;
        }
        
        .text-input {
            background-color: #151515;
            color: #B83A2D;
            border: none;
            padding: 12px 15px;
            border-radius: 10px;
            font-size: 16px;
            font-family: 'Courier New', monospace;
            margin-bottom: 15px;
            resize: none;
            flex-grow: 1;
            min-height: 260px;
        }
        
        .text-input:focus {
            outline: 2px solid #B83A2D;
        }
        
        .text-input::placeholder {
            color: #B83A2D;
            opacity: 0.5;
        }
        
        .button-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .text-button {
            background-color: #151515;
            color: #DCC9A9;
            border: none;
            padding: 12px 15px;
            border-radius: 10px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            flex: 1;
            transition: all 0.3s ease;
            text-align: center;
        }
        
        .text-button:hover {
            background-color: #252525;
        }
        
        .text-button:active {
            transform: scale(0.97);
        }
        
        .send-button {
            background-color: #B83A2D;
            color: #DCC9A9;
        }
        
        .send-button:hover {
            background-color: #C84A3D;
        }
        
        .hacker-button {
            background-color: #4E6851;
            color: #DCC9A9;
        }
        
        .hacker-button:hover {
            background-color: #5E7861;
        }
        
        /* New effect buttons styles */
        .effects-section {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(21, 21, 21, 0.3);
        }
        
        .effects-title {
            font-size: 18px;
            font-weight: bold;
            color: #151515;
            margin-bottom: 10px;
        }
        
        .effect-button {
            background-color: #151515;
            color: #DCC9A9;
            border: none;
            padding: 10px;
            border-radius: 10px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            flex: 1;
            transition: all 0.3s ease;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        .effect-button:hover {
            background-color: #252525;
        }
        
        .effect-button:active {
            transform: scale(0.97);
        }
        
        .effect-icon {
            font-size: 20px;
            margin-bottom: 5px;
        }
        
        .wobble-button {
            background-color: #4E6851;
        }
        
        .blink-button {
            background-color: #B83A2D;
        }
        
        .hacker-effect-button {
            background-color: #483D8B;
        }
        
        /* Screen text display styles */
        .screen-text-display {
            font-family: 'Courier New', monospace;
            font-size: 8px;
            fill: #E26654;
            font-weight: bold;
            line-height: 1.2;
        }

        /* New interactive eye styles */
        .interactive-eye {
            cursor: pointer;
            transition: transform 0.2s ease;
        }
        
        .interactive-eye:hover {
            transform: scale(1.1);
        }
        
        .interactive-eye:active {
            transform: scale(0.9);
        }
        
        /* Enhanced 3D dial styles */
        .dial {
            cursor: grab;
            transform-box: fill-box;
            transform-origin: center;
            transition: filter 0.2s ease;
        }
        
        .dial:hover {
            filter: brightness(1.2);
        }
        
        .dial:active {
            cursor: grabbing;
        }
        
        .dial-container {
            transform-box: fill-box;
            transform-origin: center;
        }
        
        .dial-value {
            font-family: 'Courier New', monospace;
            font-size: 6px;
            font-weight: bold;
            text-anchor: middle;
            fill: #E26654;
            pointer-events: none;
        }
        
        .dial-shadow {
            filter: blur(2px);
        }
        
        /* Symbol buttons */
        .symbol-button {
            cursor: pointer;
            fill: #E26654;
            stroke: #E26654;
            stroke-width: 1;
        }
        
        .symbol-button:hover {
            fill: #FF7B69;
            stroke: #FF7B69;
        }
        
        .symbol-button rect {
            fill: #331111;
            stroke-width: 1;
            rx: 2;
            ry: 2;
        }
        
        .symbol-button:hover rect {
            stroke: #FF7B69;
        }

        /* LED button styles */
        .led-button {
            cursor: pointer;
            transition: all 0.3s ease;
            transform-origin: center;
        }
        
        .led-button:hover {
            filter: brightness(1.2);
        }
        
        .led-button:active {
            transform: scale(0.95);
        }
        
        .led-on {
            filter: drop-shadow(0 0 5px #FF4500);
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .main-wrapper {
                flex-direction: column;
            }
            .right-panel {
                min-height: 500px;
            }
        }
    </style>
</head>
<body>
    <div class="main-wrapper">
        <div class="left-panel">
            <div class="container">
                <div class="header">
                    <div class="right-text">配色<br>参考</div>
                    <div class="header-content">
                        <div class="box-icon">日</div>
                        <div class="title-area">
                            <div class="subtitle">配色灵感 ○</div>
                            <div class="main-title">种美式复古</div>
                        </div>
                    </div>
                    
                    <div class="color-panel">
                        <div class="color-title">
                            <div class="color-title-left">高级感</div>
                            <div class="color-title-right">color</div>
                        </div>
                        <div class="color-hex">#DCC9A9</div>
                        <div class="color-note">附海报参考</div>
                        
                        <div class="color-swatches">
                            <div class="color-swatch red-swatch" id="red-swatch">
                                <div class="color-swatch-hex">#B83A2D</div>
                            </div>
                            <div class="color-swatch green-swatch" id="green-swatch">
                                <div class="color-swatch-hex">#4E6851</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="image-area">
                    <svg width="300" height="260" xmlns="http://www.w3.org/2000/svg" style="display: block; margin: 0 auto;">
                        <!-- Red background -->
                        <rect width="100%" height="100%" fill="#E26654" />
                        
                        <!-- Shadow -->
                        <ellipse cx="150" cy="220" rx="100" ry="15" fill="#000000" opacity="0.3" />
                        
                        <!-- 3D Dials on the top panel of the computer -->
                        <!-- Dial base panels - sloping down from top -->
                        <polygon points="70,50 120,55 180,55 230,50 230,40 70,40" fill="#778C7E" stroke="#333333" stroke-width="0.5" />
                        
                        <!-- Dial 1 - CONTRAST -->
                        <g class="dial-container" transform="translate(95, 47) skewX(-30) scale(1, 0.5)">
                            <!-- Dial shadow -->
                            <ellipse cx="0" cy="2" rx="12" ry="12" fill="#000000" opacity="0.3" class="dial-shadow" />
                            <!-- Dial base -->
                            <circle cx="0" cy="0" r="12" fill="#444444" stroke="#222222" stroke-width="0.5" />
                            <!-- Dial top -->
                            <circle cx="0" cy="0" r="10" fill="#666666" stroke="#333333" stroke-width="0.5" class="dial" id="dial-1" />
                            <!-- Dial center -->
                            <circle cx="0" cy="0" r="3" fill="#333333" />
                            <!-- Dial indicator line -->
                            <line x1="0" y1="0" x2="0" y2="-8" stroke="#E26654" stroke-width="1.5" id="dial-1-marker" stroke-linecap="round" />
                            <!-- Dial markers -->
                            <line x1="-8" y1="0" x2="-10" y2="0" stroke="#333333" stroke-width="1" />
                            <line x1="8" y1="0" x2="10" y2="0" stroke="#333333" stroke-width="1" />
                            <line x1="0" y1="-8" x2="0" y2="-10" stroke="#333333" stroke-width="1" />
                            <line x1="0" y1="8" x2="0" y2="10" stroke="#333333" stroke-width="1" />
                        </g>
                        <text x="95" y="58" font-family="monospace" font-size="5" fill="#E26654" text-anchor="middle" transform="skewX(-15)">CONTRAST</text>
                        <text x="95" y="39" id="dial-1-value" font-family="monospace" font-size="5" fill="#E26654" text-anchor="middle" transform="skewX(-15)">0</text>
                        
                        <!-- Dial 2 - VOLUME -->
                        <g class="dial-container" transform="translate(150, 47) skewX(-30) scale(1, 0.5)">
                            <!-- Dial shadow -->
                            <ellipse cx="0" cy="2" rx="12" ry="12" fill="#000000" opacity="0.3" class="dial-shadow" />
                            <!-- Dial base -->
                            <circle cx="0" cy="0" r="12" fill="#444444" stroke="#222222" stroke-width="0.5" />
                            <!-- Dial top -->
                            <circle cx="0" cy="0" r="10" fill="#666666" stroke="#333333" stroke-width="0.5" class="dial" id="dial-2" />
                            <!-- Dial center -->
                            <circle cx="0" cy="0" r="3" fill="#333333" />
                            <!-- Dial indicator line -->
                            <line x1="0" y1="0" x2="0" y2="-8" stroke="#E26654" stroke-width="1.5" id="dial-2-marker" stroke-linecap="round" />
                            <!-- Dial markers -->
                            <line x1="-8" y1="0" x2="-10" y2="0" stroke="#333333" stroke-width="1" />
                            <line x1="8" y1="0" x2="10" y2="0" stroke="#333333" stroke-width="1" />
                            <line x1="0" y1="-8" x2="0" y2="-10" stroke="#333333" stroke-width="1" />
                            <line x1="0" y1="8" x2="0" y2="10" stroke="#333333" stroke-width="1" />
                        </g>
                        <text x="150" y="58" font-family="monospace" font-size="5" fill="#E26654" text-anchor="middle" transform="skewX(-15)">VOLUME</text>
                        <text x="150" y="39" id="dial-2-value" font-family="monospace" font-size="5" fill="#E26654" text-anchor="middle" transform="skewX(-15)">0</text>
                        
                        <!-- Dial 3 - BRIGHTNESS -->
                        <g class="dial-container" transform="translate(205, 47) skewX(-30) scale(1, 0.5)">
                            <!-- Dial shadow -->
                            <ellipse cx="0" cy="2" rx="12" ry="12" fill="#000000" opacity="0.3" class="dial-shadow" />
                            <!-- Dial base -->
                            <circle cx="0" cy="0" r="12" fill="#444444" stroke="#222222" stroke-width="0.5" />
                            <!-- Dial top -->
                            <circle cx="0" cy="0" r="10" fill="#666666" stroke="#333333" stroke-width="0.5" class="dial" id="dial-3" />
                            <!-- Dial center -->
                            <circle cx="0" cy="0" r="3" fill="#333333" />
                            <!-- Dial indicator line -->
                            <line x1="0" y1="0" x2="0" y2="-8" stroke="#E26654" stroke-width="1.5" id="dial-3-marker" stroke-linecap="round" />
                            <!-- Dial markers -->
                            <line x1="-8" y1="0" x2="-10" y2="0" stroke="#333333" stroke-width="1" />
                            <line x1="8" y1="0" x2="10" y2="0" stroke="#333333" stroke-width="1" />
                            <line x1="0" y1="-8" x2="0" y2="-10" stroke="#333333" stroke-width="1" />
                            <line x1="0" y1="8" x2="0" y2="10" stroke="#333333" stroke-width="1" />
                        </g>
                        <text x="205" y="58" font-family="monospace" font-size="5" fill="#E26654" text-anchor="middle" transform="skewX(-15)">BRIGHTNESS</text>
                        <text x="205" y="39" id="dial-3-value" font-family="monospace" font-size="5" fill="#E26654" text-anchor="middle" transform="skewX(-15)">0</text>
                        
                        <!-- Computer body - right side panel -->
                        <polygon points="230,200 250,70 230,70 210,200" fill="#6D8073" stroke="#333" stroke-width="1" />
                        
                        <!-- Computer body - top panel -->
                        <polygon points="50,70 250,70 230,50 70,50" fill="#9BB0A1" stroke="#333" stroke-width="1" />
                        
                        <!-- Computer body - base -->
                        <polygon points="70,200 230,200 250,70 50,70" fill="#89A091" stroke="#333" stroke-width="1.5" />
                        
                        <!-- Keyboard area - front panel -->
                        <polygon points="80,170 220,170 235,200 65,200" fill="#5B6A76" stroke="#333" stroke-width="1" />
                        
                        <!-- Keyboard area - top bevel -->
                        <polygon points="75,165 225,165 220,170 80,170" fill="#6C7B87" stroke="#333" stroke-width="0.5" />
                        
                        <!-- Screen outer frame -->
                        <polygon points="65,80 235,80 225,160 75,160" fill="#89A091" stroke="#333" stroke-width="1.5" />
                        
                        <!-- Screen bevel -->
                        <polygon points="75,85 225,85 217,155 83,155" fill="#6D8073" stroke="#444" stroke-width="0.5" />
                        
                        <!-- Screen inner frame -->
                        <polygon points="80,90 220,90 212,150 88,150" fill="#333333" stroke="#222" stroke-width="1" />
                        
                        <!-- Screen display area with red glow -->
                        <polygon points="85,95 215,95 208,145 92,145" fill="#331111" stroke="#E26654" stroke-width="0.5" />
                        <rect x="87" y="97" width="126" height="45" fill="#000000" rx="2" />
                        
                        <!-- Red screen content glow effect -->
                        <rect x="87" y="97" width="126" height="45" fill="#E26654" opacity="0.1" rx="2" />
                        
                        <!-- ROBOT TEXT INTERFACE -->
                        <!-- Interface Title and Frame -->
                        <rect x="92" y="100" width="116" height="12" fill="#331111" stroke="#E26654" stroke-width="0.5" />
                        <text x="98" y="109" font-family="monospace" font-size="7" fill="#E26654" font-weight="bold">ROBOTIC VISION</text>
                        
                        <!-- Text Display Area -->
                        <rect x="92" y="114" width="116" height="26" fill="#331111" stroke="#E26654" stroke-width="0.5" id="text-display-background" />
                        
                        <!-- Text Content (Will be updated by JS) -->
                        <foreignObject x="95" y="116" width="110" height="22" id="text-display-container">
                            <div xmlns="http://www.w3.org/1999/xhtml" style="font-family: 'Courier New', monospace; font-size: 7px; color: #E26654; overflow: hidden; height: 100%; padding: 2px;">
                                <div id="screen-text-display">Awaiting text input...</div>
                            </div>
                        </foreignObject>
                        
                        <!-- Interactive Eyes with click functionality -->
                        <g id="left-eye-group" class="interactive-eye">
                            <circle cx="115" cy="127" r="9" fill="#E26654" opacity="0.2" stroke="#E26654" stroke-width="0.5" id="left-eye-outline" />
                            <circle cx="115" cy="127" r="4" fill="#E26654" id="left-eye-pupil" />
                        </g>
                        <g id="right-eye-group" class="interactive-eye">
                            <circle cx="139" cy="127" r="9" fill="#E26654" opacity="0.2" stroke="#E26654" stroke-width="0.5" id="right-eye-outline" />
                            <circle cx="139" cy="127" r="4" fill="#E26654" id="right-eye-pupil" />
                        </g>
                        
                        <!-- NEW HEART AND MUSIC BUTTONS: Positioned to right of eyes -->
                        <g id="symbol-buttons">
                            <!-- Heart Button -->
                            <g id="heart-button" class="symbol-button">
                                <rect x="165" y="119" width="16" height="16" stroke="#E26654" />
                                <path d="M173,125 C169,121 165,125 169,129 C170,130 173,133 173,133 C173,133 176,130 177,129 C181,125 177,121 173,125 Z" />
                            </g>
                            
                            <!-- Music Button -->
                            <g id="music-button" class="symbol-button">
                                <rect x="187" y="119" width="16" height="16" stroke="#E26654" />
                                <path d="M193,123 L193,130 C193,132 191,133 193,133 C195,133 197,132 197,130 L197,122 L200,121 L200,123 L197,124 L197,130 C197,132 195,133 197,133 C199,133 201,132 201,130 L201,121" />
                            </g>
                        </g>
                        
                        <!-- Line art versions of eyes (initially hidden) -->
                        <g id="line-art-eyes-container" style="display: none;">
                            <!-- Heart eye -->
                            <g id="heart-eye" transform="translate(115, 127)">
                                <circle r="9" fill="#331111" opacity="0.4" stroke="#E26654" stroke-width="0.5" />
                                <path d="M0,4 C-4,-2 -7,1 -4,4 C-2,6 0,7 0,7 C0,7 2,6 4,4 C7,1 4,-2 0,4 Z" 
                                    fill="#E26654" stroke="#E26654" stroke-width="0.5" />
                            </g>
                            
                            <!-- Music note eye -->
                            <g id="music-eye" transform="translate(139, 127)">
                                <circle r="9" fill="#331111" opacity="0.4" stroke="#E26654" stroke-width="0.5" />
                                <path d="M-3,-4 L-3,0 C-3,2 -5,3 -3,3 C-1,3 1,2 1,0 L1,-5 L4,-6 L4,-4 L1,-3 L1,0 C1,2 -1,3 1,3 C3,3 5,2 5,0 L5,-6" 
                                    fill="#E26654" stroke="#E26654" stroke-width="0.5" />
                            </g>
                        </g>
                        
                        <!-- Status indicators -->
                        <rect x="92" y="143" width="116" height="2" fill="#E26654" opacity="0.3" />
                        <rect x="92" y="143" width="30" height="2" fill="#E26654" id="status-bar" />
                        
                        <!-- Keyboard 3D details -->
                        <!-- Main keyboard panel depth -->
                        <polygon points="65,200 80,170 75,165 60,195" fill="#4A5965" stroke="#333" stroke-width="0.5" />
                        
                        <!-- Keyboard keys -->
                        <rect x="95" y="177" width="110" height="15" fill="#444444" stroke="#222222" stroke-width="0.5" rx="1" />
                        <!-- Key shadows for 3D effect -->
                        <rect x="95" y="177" width="110" height="2" fill="#333333" />
                        
                        <!-- Individual keys with 3D effect -->
                        <!-- Red key - LED Control Button -->
                        <g id="red-led-button" class="led-button">
                            <rect x="120" y="181" width="15" height="7" fill="#B83A2D" stroke="#222222" stroke-width="0.5" rx="1" />
                            <rect x="120" y="181" width="15" height="2" fill="#C25545" />
                            <!-- LED indicator -->
                            <circle cx="127.5" cy="184.5" r="1.5" fill="#FFCC00" opacity="0" id="led-indicator" />
                        </g>
                        
                        <!-- Gray keys with highlights -->
                        <rect x="145" y="181" width="15" height="7" fill="#666666" stroke="#222222" stroke-width="0.5" rx="1" />
                        <rect x="145" y="181" width="15" height="2" fill="#555555" />
                        
                        <rect x="170" y="181" width="15" height="7" fill="#666666" stroke="#222222" stroke-width="0.5" rx="1" />
                        <rect x="170" y="181" width="15" height="2" fill="#555555" />
                        
                        <!-- Side details -->
                        <!-- Left side elements -->
                        <circle cx="55" cy="100" r="5" fill="#912D2D" stroke="#333333" stroke-width="1" />
                        <!-- Bevel on circular element -->
                        <path d="M55,95 a5,5 0 0 1 0,10" fill="none" stroke="#7A2626" stroke-width="1" />
                        
                        <!-- Left side panel -->
                        <polygon points="50,70 65,80 75,160 65,200 70,200 80,170 75,160 65,80 50,70" fill="#778C7E" stroke="#333333" stroke-width="0.5" />
                        
                        <!-- Side vents with depth -->
                        <rect x="52" y="130" width="10" height="20" fill="#6D8073" stroke="#333333" stroke-width="0.5" />
                        <line x1="54" y1="132" x2="54" y2="148" stroke="#555555" stroke-width="1" />
                        <line x1="57" y1="132" x2="57" y2="148" stroke="#555555" stroke-width="1" />
                        <line x1="60" y1="132" x2="60" y2="148" stroke="#555555" stroke-width="1" />
                        
                        <!-- Right side details -->
                        <rect x="238" y="120" width="7" height="20" fill="#6D8073" stroke="#333333" stroke-width="0.5" rx="1" />
                        <rect x="238" y="150" width="7" height="20" fill="#6D8073" stroke="#333333" stroke-width="0.5" rx="1" />
                        
                        <!-- Highlights for 3D effect -->
                        <!-- Top edge highlight -->
                        <line x1="70" y1="50" x2="230" y2="50" stroke="#FFFFFF" stroke-width="0.5" opacity="0.3" />
                        
                        <!-- Left edge highlight -->
                        <line x1="50" y1="70" x2="70" y2="50" stroke="#FFFFFF" stroke-width="0.5" opacity="0.3" />
                        
                        <!-- Screen glass reflection -->
                        <polygon points="90,95 205,95 200,100 95,100" fill="#FFFFFF" opacity="0.1" />
                        
                        <!-- Scanlines for CRT effect -->
                        <rect x="87" y="97" width="126" height="45" fill="url(#scanlines)" opacity="0.1" />
                        
                        <!-- Definitions for patterns and gradients -->
                        <defs>
                            <pattern id="scanlines" patternUnits="userSpaceOnUse" width="4" height="4">
                                <rect width="4" height="2" fill="#FFFFFF" opacity="0.1" />
                            </pattern>
                        </defs>
                    </svg>
                </div>
                
                <div class="footer">
                    <div class="logo">
                        <div class="logo-circle"></div>
                        <div class="logo-text">DESIGN</div>
                    </div>
                    <div class="footer-content">
                        <div class="footer-text">DAILY PORTFOLIO</div>
                        <div class="footer-divider"></div>
                        <div class="footer-text">SHARE</div>
                    </div>
                </div>
                
                <div class="connection-status">
                    <span class="status-indicator status-disconnected" id="mqtt-status"></span>
                    <span id="connection-text">Not connected to robot</span>
                </div>
            </div>
        </div>
        
        <div class="right-panel">
            <div class="text-panel">
                <div class="text-panel-title">Text Display Panel</div>
                <textarea class="text-input" id="custom-text" placeholder="Enter text to display on the robot screen..." maxlength="90"></textarea>
                <div class="button-row">
                    <button class="text-button" id="clear-button">Clear</button>
                    <button class="text-button hacker-button" id="hacker-button">Hacker Mode</button>
                    <button class="text-button send-button" id="send-text-button">Send Text</button>
                </div>
                
                <!-- New effects section -->
                <div class="effects-section">
                    <div class="effects-title">Special Effects</div>
                    <div class="button-row">
                        <button class="effect-button wobble-button" id="wobble-button">
                            <span class="effect-icon">↯</span>
                            Wobble
                        </button>
                        <button class="effect-button blink-button" id="blink-button">
                            <span class="effect-icon">◑</span>
                            Blink
                        </button>
                        <button class="effect-button hacker-effect-button" id="hacker-effect-button">
                            <span class="effect-icon">⌨</span>
                            Hacker Code
                        </button>
                    </div>
                </div>
                
                <div class="connection-status" style="margin-top: auto; padding-top: 15px;">
                    <span class="status-indicator status-disconnected" id="right-mqtt-status"></span>
                    <span id="right-connection-text">Not connected to robot</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // MQTT Connection variables
        let client;
        const broker = "broker.emqx.io";
        const port = 8084;  // Secure WebSocket port for EMQX
        const baseTopic = "esp32/123132132312";
        const eyesTopic = `${baseTopic}/eyes`;
        const eyesHueTopic = `${eyesTopic}/hue`;
        const eyesTextTopic = `${eyesTopic}/text`;
        const eyesEffectTopic = `${eyesTopic}/effect`; // Topic for effects
        const eyesSymbolTopic = `${eyesTopic}/symbol`; // Topic for symbols (heart, music)
        const eyesLedTopic = `${eyesTopic}/led`; // Topic for LED control
        
        // Client ID - random to avoid conflicts
        const clientId = "robot_eyes_" + Math.random().toString(16).substr(2, 8);
        
        // UI Elements
        const statusIndicator = document.getElementById('mqtt-status');
        const connectionText = document.getElementById('connection-text');
        const rightStatusIndicator = document.getElementById('right-mqtt-status');
        const rightConnectionText = document.getElementById('right-connection-text');
        const customTextArea = document.getElementById('custom-text');
        const sendTextButton = document.getElementById('send-text-button');
        const clearButton = document.getElementById('clear-button');
        const hackerButton = document.getElementById('hacker-button');
        const screenTextDisplay = document.getElementById('screen-text-display');
        const statusBar = document.getElementById('status-bar');
        const leftEyeOutline = document.getElementById('left-eye-outline');
        const rightEyeOutline = document.getElementById('right-eye-outline');
        const leftEyePupil = document.getElementById('left-eye-pupil');
        const rightEyePupil = document.getElementById('right-eye-pupil');
        
        // LED Control Elements
        const redLedButton = document.getElementById('red-led-button');
        const ledIndicator = document.getElementById('led-indicator');
        let ledState = false; // Track LED state
        
        // Interactive Eye Elements
        const leftEyeGroup = document.getElementById('left-eye-group');
        const rightEyeGroup = document.getElementById('right-eye-group');
        const lineArtEyesContainer = document.getElementById('line-art-eyes-container');
        
        // Symbol Button Elements
        const heartButton = document.getElementById('heart-button');
        const musicButton = document.getElementById('music-button');
        
        // Dial Elements
        const dial1 = document.getElementById('dial-1');
        const dial2 = document.getElementById('dial-2');
        const dial3 = document.getElementById('dial-3');
        const dial1Marker = document.getElementById('dial-1-marker');
        const dial2Marker = document.getElementById('dial-2-marker');
        const dial3Marker = document.getElementById('dial-3-marker');
        const dial1Value = document.getElementById('dial-1-value');
        const dial2Value = document.getElementById('dial-2-value');
        const dial3Value = document.getElementById('dial-3-value');
        
        // Effect Buttons
        const wobbleButton = document.getElementById('wobble-button');
        const blinkButton = document.getElementById('blink-button');
        const hackerEffectButton = document.getElementById('hacker-effect-button');
        
        // Function to set text display mode
        function setTextDisplayMode(showText = true) {
            // Toggle visibility of eyes and text
            const textDisplayContainer = document.getElementById('text-display-container');
            
            if (showText) {
                // Show text, semi-hide eyes
                textDisplayContainer.style.display = 'block';
                
                // Make eyes less visible but keep them for color indication
                leftEyeOutline.setAttribute('opacity', '0.1');
                rightEyeOutline.setAttribute('opacity', '0.1');
                leftEyePupil.setAttribute('opacity', '0.1');
                rightEyePupil.setAttribute('opacity', '0.1');
                
            } else {
                // Show eyes, hide text
                textDisplayContainer.style.display = 'none';
                
                // Make eyes fully visible
                leftEyeOutline.setAttribute('opacity', '0.2');
                rightEyeOutline.setAttribute('opacity', '0.2');
                leftEyePupil.setAttribute('opacity', '1');
                rightEyePupil.setAttribute('opacity', '1');
            }
        }
        
        // Function to toggle LED state
        function toggleLed() {
            ledState = !ledState;
            updateLedIndicator();
            
            // Send MQTT message
            if (client && client.isConnected()) {
                sendMessage(eyesLedTopic, "toggle");
                connectionText.textContent = ledState ? "LED turned ON" : "LED turned OFF";
                rightConnectionText.textContent = ledState ? "LED turned ON" : "LED turned OFF";
            } else {
                connectionText.textContent = `LED would be turned ${ledState ? "ON" : "OFF"} (local only)`;
                rightConnectionText.textContent = `LED would be turned ${ledState ? "ON" : "OFF"} (local only)`;
            }
            
            // Display text on screen about LED status
            setTextDisplayMode(true);
            screenTextDisplay.innerHTML = `LED is now <span style="color:#FFCC00">${ledState ? "ON" : "OFF"}</span>`;
            
            // Set a timer to go back to eyes after a moment
            setTimeout(() => {
                setTextDisplayMode(false);
            }, 1500);
        }
        
        // Update the LED indicator visually
        function updateLedIndicator() {
            if (ledState) {
                // LED is ON
                ledIndicator.setAttribute('opacity', '1');
                redLedButton.classList.add('led-on');
            } else {
                // LED is OFF
                ledIndicator.setAttribute('opacity', '0');
                redLedButton.classList.remove('led-on');
            }
        }
        
        // Connect to MQTT broker
        function connectMQTT() {
            // Update status
            connectionText.textContent = "Connecting to robot...";
            
            // Create a client instance with unique client ID
            client = new Paho.MQTT.Client(broker, port, clientId);
            
            // Set callback handlers
            client.onConnectionLost = onConnectionLost;
            client.onMessageArrived = onMessageArrived;
            
            // Connect
            client.connect({
                onSuccess: onConnect,
                useSSL: true,
                timeout: 5,
                onFailure: onConnectionFailure,
                mqttVersion: 4,
                keepAliveInterval: 60
            });
        }
        
        // When successfully connected
        function onConnect() {
            console.log("Connected to MQTT broker");
            // Update both status indicators
            statusIndicator.classList.remove('status-disconnected');
            statusIndicator.classList.add('status-connected');
            rightStatusIndicator.classList.remove('status-disconnected');
            rightStatusIndicator.classList.add('status-connected');
            
            // Update both status texts
            connectionText.textContent = "Connected to robot control system";
            rightConnectionText.textContent = "Connected to robot control system";
            
            // Subscribe to topics
            client.subscribe(`${eyesTopic}/state`);
            client.subscribe(`${eyesTopic}/led_state`); // Subscribe to LED state updates
        }
        
        // Handle connection failures
        function onConnectionFailure(error) {
            console.log("Failed to connect to MQTT broker:", error);
            // Update both status indicators
            statusIndicator.classList.remove('status-connected');
            statusIndicator.classList.add('status-disconnected');
            rightStatusIndicator.classList.remove('status-connected');
            rightStatusIndicator.classList.add('status-disconnected');
            
            // Update both status texts
            connectionText.textContent = "Failed to connect to robot";
            rightConnectionText.textContent = "Failed to connect to robot";
            
            // Retry connection after 5 seconds
            setTimeout(connectMQTT, 5000);
        }
        
        // Handle connection loss
        function onConnectionLost(responseObject) {
            // Update both status indicators
            statusIndicator.classList.remove('status-connected');
            statusIndicator.classList.add('status-disconnected');
            rightStatusIndicator.classList.remove('status-connected');
            rightStatusIndicator.classList.add('status-disconnected');
            
            if (responseObject.errorCode !== 0) {
                console.log("Connection lost:", responseObject.errorMessage);
                // Update both status texts
                connectionText.textContent = "Connection to robot lost";
                rightConnectionText.textContent = "Connection to robot lost";
                
                // Retry connection after 5 seconds
                setTimeout(connectMQTT, 5000);
            } else {
                // Update both status texts
                connectionText.textContent = "Disconnected from robot";
                rightConnectionText.textContent = "Disconnected from robot";
            }
        }
        
        // Handle incoming messages
        function onMessageArrived(message) {
            console.log("Message received:", message.payloadString);
            
            // Handle LED state updates
            if (message.destinationName === `${eyesTopic}/led_state`) {
                const state = message.payloadString;
                ledState = (state === "on");
                updateLedIndicator();
                console.log("LED state updated from server:", ledState);
            }
            // Handle state updates if needed
            else if (message.destinationName === `${eyesTopic}/state`) {
                try {
                    const state = JSON.parse(message.payloadString);
                    console.log("Robot state:", state);
                    // Update UI based on state if needed
                } catch (e) {
                    console.error("Error parsing state:", e);
                }
            }
        }
        
        // Send message to topic
        function sendMessage(topic, message) {
            if (!client || !client.isConnected()) {
                console.log("Not connected to MQTT broker");
                // Update both status texts
                connectionText.textContent = "Not connected to robot - cannot send command";
                rightConnectionText.textContent = "Not connected to robot - cannot send command";
                return false;
            }
            
            const mqttMessage = new Paho.MQTT.Message(message);
            mqttMessage.destinationName = topic;
            
            try {
                client.send(mqttMessage);
                console.log(`Sent to ${topic}: ${message}`);
                // Update both status texts
                connectionText.textContent = `Sent command to robot: ${message}`;
                rightConnectionText.textContent = `Sent command to robot: ${message}`;
                return true;
            } catch (error) {
                console.log("Error sending message:", error);
                // Update both status texts
                connectionText.textContent = "Error sending command to robot";
                rightConnectionText.textContent = "Error sending command to robot";
                return false;
            }
        }
        
        // Function to show heart symbol
        function showHeartSymbol() {
            console.log("Heart symbol clicked!");
            
            // Hide regular eyes
            leftEyeGroup.style.display = 'none';
            rightEyeGroup.style.display = 'none';
            
            // Show line art eyes (which include the heart)
            lineArtEyesContainer.style.display = 'block';
            
            // Display heart text on screen
            setTextDisplayMode(true);
            screenTextDisplay.innerHTML = `
                <span style="color:#E26654; font-size: 12px;">♥</span> HEART SYMBOL <span style="color:#E26654; font-size: 12px;">♥</span>
            `;
            
            // Send heart symbol command to ESP32/SSD1351
            if (client && client.isConnected()) {
                sendMessage(eyesSymbolTopic, "heart");
                connectionText.textContent = "Sent heart symbol to display";
                rightConnectionText.textContent = "Sent heart symbol to display";
            } else {
                // Local display if not connected
                connectionText.textContent = "Heart symbol displayed (local only)";
                rightConnectionText.textContent = "Heart symbol displayed (local only)";
            }
            
            // Animate the status bar
            let width = 0;
            const interval = setInterval(() => {
                width += 5;
                if (width > 116) {
                    clearInterval(interval);
                }
                statusBar.setAttribute('width', width);
            }, 50);
            
            // Set a timer to go back to eyes after 3 seconds
            setTimeout(() => {
                // Hide line art eyes
                lineArtEyesContainer.style.display = 'none';
                
                // Show regular eyes
                leftEyeGroup.style.display = 'block';
                rightEyeGroup.style.display = 'block';
                
                // Go back to eyes display
                setTextDisplayMode(false);
                
                // Reset status bar
                statusBar.setAttribute('width', '30');
            }, 3000);
        }
        
        // Function to show music symbol
        function showMusicSymbol() {
            console.log("Music symbol clicked!");
            
            // Hide regular eyes
            leftEyeGroup.style.display = 'none';
            rightEyeGroup.style.display = 'none';
            
            // Show line art eyes (which include the music note)
            lineArtEyesContainer.style.display = 'block';
            
            // Display music text on screen
            setTextDisplayMode(true);
            screenTextDisplay.innerHTML = `
                <span style="color:#E26654; font-size: 12px;">♪</span> MUSIC SYMBOL <span style="color:#E26654; font-size: 12px;">♪</span>
            `;
            
            // Send music symbol command to ESP32/SSD1351
            if (client && client.isConnected()) {
                sendMessage(eyesSymbolTopic, "music");
                connectionText.textContent = "Sent music symbol to display";
                rightConnectionText.textContent = "Sent music symbol to display";
            } else {
                // Local display if not connected
                connectionText.textContent = "Music symbol displayed (local only)";
                rightConnectionText.textContent = "Music symbol displayed (local only)";
            }
            
            // Animate the status bar
            let width = 0;
            const interval = setInterval(() => {
                width += 5;
                if (width > 116) {
                    clearInterval(interval);
                }
                statusBar.setAttribute('width', width);
            }, 50);
            
            // Set a timer to go back to eyes after 3 seconds
            setTimeout(() => {
                // Hide line art eyes
                lineArtEyesContainer.style.display = 'none';
                
                // Show regular eyes
                leftEyeGroup.style.display = 'block';
                rightEyeGroup.style.display = 'block';
                
                // Go back to eyes display
                setTextDisplayMode(false);
                
                // Reset status bar
                statusBar.setAttribute('width', '30');
            }, 3000);
        }
        
        // Function to format text in a hacker style
        function formatHackerText(text) {
            // Add hacker-like formatting with brackets, semicolons, etc.
            const lines = text.split('\n');
            const formattedLines = lines.map(line => {
                // Skip empty lines
                if (!line.trim()) return '';
                
                // Random formatting styles
                const format = Math.floor(Math.random() * 4);
                
                switch(format) {
                    case 0:
                        return `{ ${line}; }`;
                    case 1:
                        return `<${line}>`;
                    case 2:
                        return `[${line}]`;
                    case 3:
                        return `function() { ${line}; }`;
                    default:
                        return line;
                }
            });
            
            return formattedLines.join('\n');
        }
        
        // Function to update the screen display with typing animation
        function updateScreenDisplay(text) {
            // Make screen display visible
            setTextDisplayMode(true);
            
            // Format the text for display
            const formattedText = formatTextForDisplay(text);
            
            // Create typing animation
            const plainText = formattedText.replace(/<br>/g, ' ');
            let currentPos = 0;
            screenTextDisplay.innerHTML = '_'; // Start with cursor
            
            // Clear any existing typing intervals
            if (window.typingInterval) clearInterval(window.typingInterval);
            
            // Typing interval
            window.typingInterval = setInterval(() => {
                if (currentPos < plainText.length) {
                    // Get next character
                    let nextChar = plainText.charAt(currentPos);
                    currentPos++;
                    
                    // If it's a space and at a position divisible by 18 (end of line), replace with <br>
                    if (nextChar === ' ' && (currentPos % 18 === 0 || currentPos % 18 === 1)) {
                        nextChar = '<br>';
                    }
                    
                    // Update display with current text + cursor
                    const displayText = plainText.substring(0, currentPos) + '_';
                    screenTextDisplay.innerHTML = displayText.replace(/(.{18})/g, '$1<br>');
                    
                    // Send incremental text to ESP32
                    if (client && client.isConnected()) {
                        sendMessage(eyesTextTopic, plainText.substring(0, currentPos));
                    }
                } else {
                    // Typing finished
                    clearInterval(window.typingInterval);
                    screenTextDisplay.innerHTML = formattedText; // Final text without cursor
                    
                    // Animated status bar
                    let width = 0;
                    const interval = setInterval(() => {
                        width += 5;
                        if (width > 116) {
                            clearInterval(interval);
                            width = 30;
                        }
                        statusBar.setAttribute('width', width);
                    }, 50);
                    
                    // Set a timer to go back to eyes after 3 seconds from the end of typing
                    setTimeout(() => {
                        setTextDisplayMode(false);
                    }, 3000);
                }
            }, 150); // Speed of typing animation, adjust as needed
        }
        
        // Function to format text for display
        function formatTextForDisplay(text) {
            // Break text into lines to fit the display
            const maxCharsPerLine = 18; // Adjust based on font size
            let result = '';
            let lineCount = 0;
            
            // Split by newlines first
            const paragraphs = text.split('\n');
            
            for (const paragraph of paragraphs) {
                if (lineCount >= 3) break; // Only show first 3 lines
                
                // Handle long lines
                if (paragraph.length <= maxCharsPerLine) {
                    result += paragraph + '<br>';
                    lineCount++;
                } else {
                    // Split long paragraphs
                    let remainingText = paragraph;
                    while (remainingText.length > 0 && lineCount < 3) {
                        result += remainingText.substring(0, maxCharsPerLine) + '<br>';
                        remainingText = remainingText.substring(maxCharsPerLine);
                        lineCount++;
                    }
                }
                
                if (lineCount >= 3) break;
            }
            
            return result;
        }
        
        // Function to change the eye color
        function changeEyeColor(color) {
            // Change the stroke and fill colors
            leftEyeOutline.setAttribute('stroke', color);
            rightEyeOutline.setAttribute('stroke', color);
            leftEyeOutline.setAttribute('fill', color);
            rightEyeOutline.setAttribute('fill', color);
            leftEyePupil.setAttribute('fill', color);
            rightEyePupil.setAttribute('fill', color);
            
            // Create a "changing" effect
            leftEyePupil.setAttribute('r', '5'); // Make pupils slightly larger
            rightEyePupil.setAttribute('r', '5');
            
            setTimeout(() => {
                leftEyePupil.setAttribute('r', '4'); // Return to normal size
                rightEyePupil.setAttribute('r', '4');
            }, 200);
            
            // Update text display color as well
            document.getElementById('screen-text-display').style.color = color;
            document.getElementById('text-display-background').setAttribute('stroke', color);
            
            // Update heart and music button colors
            const heartButtonElements = document.querySelectorAll('#heart-button rect, #heart-button path');
            const musicButtonElements = document.querySelectorAll('#music-button rect, #music-button path');
            
            heartButtonElements.forEach(el => {
                if (el.tagName === 'path') {
                    el.setAttribute('fill', color);
                }
                el.setAttribute('stroke', color);
            });
            
            musicButtonElements.forEach(el => {
                if (el.tagName === 'path') {
                    el.setAttribute('fill', color);
                }
                el.setAttribute('stroke', color);
            });
            
            // Update line art eyes color
            const lineArtEyePaths = document.querySelectorAll('#line-art-eyes-container path');
            lineArtEyePaths.forEach(el => {
                if (el.getAttribute('fill') !== 'none' && el.getAttribute('fill') !== '#331111') {
                    el.setAttribute('fill', color);
                }
                if (el.hasAttribute('stroke')) {
                    el.setAttribute('stroke', color);
                }
            });
            
            // Convert color hex to hue for the ESP32
            let hue;
            if (color === '#B83A2D') { // Red
                hue = "0"; // 0 degrees in HSV is red
                if (client && client.isConnected()) {
                    sendMessage(eyesHueTopic, hue);
                }
            } else if (color === '#4E6851') { // Green
                hue = "120"; // 120 degrees in HSV is green
                if (client && client.isConnected()) {
                    sendMessage(eyesHueTopic, hue);
                }
            }
            
            console.log(`Changing robot eyes to ${color} (hue: ${hue})`);
        }
        
        // Send custom text to display
        function sendCustomText() {
            const text = customTextArea.value.trim();
            
            if (!text) {
                connectionText.textContent = "Please enter text to display";
                return;
            }
            
            if (text.length > 90) {
                connectionText.textContent = "Text is too long (max 90 characters)";
                return;
            }
            
            // First trigger a quick wobble effect
            if (client && client.isConnected()) {
                connectionText.textContent = "Sending quick wobble effect...";
                rightConnectionText.textContent = "Sending quick wobble effect...";
                
                sendMessage(eyesEffectTopic, "quickwobble");
                
                // Then display the text after the quick wobble effect (approx 0.5 seconds)
                setTimeout(() => {
                    // Update the screen display with typing animation
                    updateScreenDisplay(text);
                    
                    // Update status
                    connectionText.textContent = `Typing text on robot: "${text.substring(0, 20)}${text.length > 20 ? '...' : ''}"`;
                }, 500); // Quick wobble is about 300ms, we wait a bit longer
            } else {
                // If not connected, just update screen locally
                updateScreenDisplay(text);
            }
        }
        
        // Format and send text in hacker style
        function sendHackerText() {
            let text = customTextArea.value.trim();
            
            if (!text) {
                connectionText.textContent = "Please enter text to display in hacker mode";
                return;
            }
            
            // Format the text
            const formattedText = formatHackerText(text);
            customTextArea.value = formattedText;
            
            // Show formatted text
            connectionText.textContent = "Text formatted in hacker style";
            
            // First trigger a quick wobble effect
            if (client && client.isConnected()) {
                connectionText.textContent = "Sending quick wobble effect before hacker text...";
                rightConnectionText.textContent = "Sending quick wobble effect before hacker text...";
                
                sendMessage(eyesEffectTopic, "quickwobble");
                
                // Then display the hacker text after the quick wobble effect
                setTimeout(() => {
                    // Update the screen display with typing animation
                    updateScreenDisplay(formattedText);
                    
                    // Check length
                    if (formattedText.length > 90) {
                        connectionText.textContent = "Formatted text is too long (max 90 characters)";
                    }
                }, 500); // Quick wobble is about 300ms, we wait a bit longer
            } else {
                // If not connected, just update screen locally
                updateScreenDisplay(formattedText);
            }
        }
        
        // Trigger quick wobble effect (used for eye clicks)
        function triggerQuickWobbleEffect() {
            if (client && client.isConnected()) {
                sendMessage(eyesEffectTopic, "quickwobble");
                connectionText.textContent = "Quick wobble effect triggered";
                rightConnectionText.textContent = "Quick wobble effect triggered";
            }
            
            // Always do local animation for immediate visual feedback
            animateQuickWobble();
            
            // Also display a quick message on the screen
            setTextDisplayMode(true);
            screenTextDisplay.innerHTML = "Eye contact!";
            
            // Go back to eyes after a moment
            setTimeout(() => {
                setTextDisplayMode(false);
            }, 1500);
        }
        
        // Local animation for quick wobble
        function animateQuickWobble() {
            const eyes = [leftEyePupil, rightEyePupil];
            let wobbleCount = 0;
            const maxWobbles = 5;
            const wobbleInterval = setInterval(() => {
                const offsetX = (Math.random() - 0.5) * 3;
                const offsetY = (Math.random() - 0.5) * 3;
                
                eyes.forEach(eye => {
                    const cx = parseInt(eye.getAttribute('cx'));
                    const cy = parseInt(eye.getAttribute('cy'));
                    eye.setAttribute('cx', cx + offsetX);
                    eye.setAttribute('cy', cy + offsetY);
                });
                
                wobbleCount++;
                if (wobbleCount >= maxWobbles) {
                    clearInterval(wobbleInterval);
                    // Reset eye positions
                    leftEyePupil.setAttribute('cx', '115');
                    leftEyePupil.setAttribute('cy', '127');
                    rightEyePupil.setAttribute('cx', '139');
                    rightEyePupil.setAttribute('cy', '127');
                }
            }, 80);
        }
        
        // Trigger wobble effect
        function triggerWobbleEffect() {
            if (client && client.isConnected()) {
                sendMessage(eyesEffectTopic, "wobble");
                connectionText.textContent = "Wobble effect triggered";
                rightConnectionText.textContent = "Wobble effect triggered";
            }
            
            // Visual feedback - briefly animate the button
            wobbleButton.style.transform = "translateX(5px)";
            setTimeout(() => {
                wobbleButton.style.transform = "translateX(0)";
            }, 300);
            
            // Also do local wobble animation
            animateQuickWobble();
        }
        
        // Trigger blink effect
        function triggerBlinkEffect() {
            if (client && client.isConnected()) {
                sendMessage(eyesEffectTopic, "blink");
                connectionText.textContent = "Blink effect triggered";
                rightConnectionText.textContent = "Blink effect triggered";
            }
            
            // Visual feedback - briefly animate the button
            blinkButton.style.transform = "translateX(5px)";
            setTimeout(() => {
                blinkButton.style.transform = "translateX(0)";
            }, 300);
            
            // Local blink animation
            const eyes = [leftEyePupil, rightEyePupil];
            eyes.forEach(eye => {
                eye.setAttribute('r', '0');
            });
            
            setTimeout(() => {
                eyes.forEach(eye => {
                    eye.setAttribute('r', '4');
                });
            }, 200);
        }
        
        // Trigger hacker code effect
        function triggerHackerCodeEffect() {
            if (client && client.isConnected()) {
                sendMessage(eyesEffectTopic, "hacker");
                connectionText.textContent = "Hacker code effect triggered";
                rightConnectionText.textContent = "Hacker code effect triggered";
            }
            
            // Visual feedback - briefly animate the button
            hackerEffectButton.style.transform = "translateX(5px)";
            setTimeout(() => {
                hackerEffectButton.style.transform = "translateX(0)";
            }, 300);
            
            // Show hacker text on screen
            setTextDisplayMode(true);
            const hackerText = "HACKING...\n[System Breach]\n<ACCESS GRANTED>";
            updateScreenDisplay(hackerText);
        }
        
        // Dial rotation handler with 3D perspective support
        function setupDial(dialElement, markerElement, valueElement) {
            let isDragging = false;
            let startMouseAngle = 0;
            let currentAngle = 0;
            
            function getRotationCenterPoint(element) {
                // For our specific setup, we're using skewX and scale transforms
                // The center is the first two values in the transform string after translate
                const transform = element.parentNode.getAttribute('transform');
                const match = transform.match(/translate\(([^,]+),\s*([^)]+)\)/);
                if (match) {
                    return {
                        x: parseFloat(match[1]),
                        y: parseFloat(match[2])
                    };
                }
                // Fallback to element's cx and cy if available
                return {
                    x: parseFloat(element.getAttribute('cx') || 0),
                    y: parseFloat(element.getAttribute('cy') || 0)
                };
            }
            
            function updateDialRotation(angle) {
                // Constrain angle between 0 and 270 degrees (3/4 of a full circle)
                angle = Math.max(0, Math.min(270, angle));
                
                // Calculate the value (0-100) based on angle
                const value = Math.round((angle / 270) * 100);
                valueElement.textContent = value;
                
                // Rotate the marker line
                const center = getRotationCenterPoint(dialElement);
                markerElement.setAttribute('transform', `rotate(${angle})`);
                
                return angle;
            }
            
            dialElement.addEventListener('mousedown', function(e) {
                e.preventDefault();
                isDragging = true;
                
                // Get the center point for this dial
                const center = getRotationCenterPoint(dialElement);
                
                // Calculate SVG coordinates
                const svgRect = dialElement.ownerSVGElement.getBoundingClientRect();
                const mouseX = e.clientX - svgRect.left;
                const mouseY = e.clientY - svgRect.top;
                
                // Calculate angle relative to center (in degrees)
                startMouseAngle = Math.atan2(mouseY - center.y, mouseX - center.x) * (180 / Math.PI);
                startMouseAngle = (startMouseAngle + 360) % 360; // Normalize to 0-360
                
                // Add grabbing cursor to the document
                document.body.style.cursor = 'grabbing';
                
                // Add event listeners for mouse movement
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });
            
            function onMouseMove(e) {
                if (!isDragging) return;
                
                // Get the center point
                const center = getRotationCenterPoint(dialElement);
                
                // Calculate SVG coordinates
                const svgRect = dialElement.ownerSVGElement.getBoundingClientRect();
                const mouseX = e.clientX - svgRect.left;
                const mouseY = e.clientY - svgRect.top;
                
                // Calculate current angle (in degrees)
                let currentMouseAngle = Math.atan2(mouseY - center.y, mouseX - center.x) * (180 / Math.PI);
                currentMouseAngle = (currentMouseAngle + 360) % 360; // Normalize to 0-360
                
                // Calculate the change in angle
                let deltaAngle = currentMouseAngle - startMouseAngle;
                
                // Handle the case where the angle crosses the 0/360 boundary
                if (deltaAngle > 180) deltaAngle -= 360;
                if (deltaAngle < -180) deltaAngle += 360;
                
                // Update rotation angle
                currentAngle += deltaAngle;
                currentAngle = updateDialRotation(currentAngle);
                
                // Update start angle for next movement
                startMouseAngle = currentMouseAngle;
            }
            
            function onMouseUp() {
                isDragging = false;
                document.body.style.cursor = '';
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            }
            
            // Initialize dial position to 0
            updateDialRotation(0);
        }
        
        // Initialize MQTT connection and UI when page loads
        window.addEventListener('load', function() {
            // Start with eyes visible, not text
            setTextDisplayMode(false);
            
            // Initialize dials with 3D perspective adjustments
            setupDial(dial1, dial1Marker, dial1Value);
            setupDial(dial2, dial2Marker, dial2Value);
            setupDial(dial3, dial3Marker, dial3Value);
            
            // Add click event listeners to the eyes
            leftEyeGroup.addEventListener('click', triggerQuickWobbleEffect);
            rightEyeGroup.addEventListener('click', triggerQuickWobbleEffect);
            
            // Add click event listener to the LED button
            redLedButton.addEventListener('click', function(e) {
                e.stopPropagation(); // Prevent event bubbling
                console.log("LED button clicked");
                toggleLed();
            });
            
            // Add click event listeners to the heart and music buttons
            heartButton.addEventListener('click', function(e) {
                e.stopPropagation(); // Prevent event bubbling
                console.log("Heart button clicked");
                showHeartSymbol();
            });
            
            musicButton.addEventListener('click', function(e) {
                e.stopPropagation(); // Prevent event bubbling
                console.log("Music button clicked");
                showMusicSymbol();
            });
            
            // Make sure these symbol buttons have pointer-events enabled
            heartButton.style.pointerEvents = 'auto';
            musicButton.style.pointerEvents = 'auto';
            redLedButton.style.pointerEvents = 'auto';
            
            // Check if we have the MQTT client library
            if (typeof Paho !== 'undefined') {
                connectMQTT();
            } else {
                console.log("MQTT client library not available");
                // Update both status texts
                connectionText.textContent = "MQTT library not available - cannot control robot";
                rightConnectionText.textContent = "MQTT library not available - cannot control robot";
            }
            
            // Add click event listeners to the color swatches
            document.getElementById('red-swatch').addEventListener('click', function() {
                changeEyeColor('#B83A2D');
            });
            
            document.getElementById('green-swatch').addEventListener('click', function() {
                changeEyeColor('#4E6851');
            });
            
            // Add event listeners for text buttons
            sendTextButton.addEventListener('click', sendCustomText);
            clearButton.addEventListener('click', function() {
                customTextArea.value = '';
                connectionText.textContent = "Text cleared";
                // Reset screen display
                screenTextDisplay.innerHTML = "Text cleared...";
                // Show text display momentarily when clearing
                setTextDisplayMode(true);
                
                // Go back to eyes after a moment
                setTimeout(() => {
                    setTextDisplayMode(false);
                }, 1500);
            });
            hackerButton.addEventListener('click', sendHackerText);
            
            // Add event listeners for effect buttons
            wobbleButton.addEventListener('click', triggerWobbleEffect);
            blinkButton.addEventListener('click', triggerBlinkEffect);
            hackerEffectButton.addEventListener('click', triggerHackerCodeEffect);
            
            // Add textarea keyboard event
            customTextArea.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && e.ctrlKey) {
                    e.preventDefault();
                    sendCustomText();
                }
            });
            
            // Double-check symbol buttons are clickable
            const symbolButtons = document.getElementById('symbol-buttons');
            if (symbolButtons) {
                // Make sure buttons are at the top of the SVG for proper z-index
                const svg = document.querySelector('svg');
                if (svg) {
                    svg.appendChild(symbolButtons);
                }
                
                // Fix any pointer event issues
                const allSymbolPaths = symbolButtons.querySelectorAll('path, rect');
                allSymbolPaths.forEach(el => {
                    el.style.pointerEvents = 'auto';
                });
            }
        });
    </script>
</body>
</html>